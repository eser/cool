// Copyright 2023-present Eser Ozvataf and other contributors. All rights reserved. Apache-2.0 license.

// This file contains code from deno fresh (https://github.com/denoland/fresh),
// which is a web framework, licensed under the MIT license.

// Copyright (c) 2023 Eser Ozvataf and other contributors
// Copyright (c) 2021-2023 Luca Casonato

import { path, posix } from "./deps.ts";
import * as runtime from "../standards/runtime.ts";
import * as logger from "../logging/logger.ts";
import * as validatorIdentifier from "./validator-identifier/mod.ts";
import * as collector from "./collector.ts";
import * as formatter from "./formatter.ts";

const IMPORT_PREFIX = "$$";
const PLACEHOLDER_PREFIX = `##!!//__`;
const PLACEHOLDER_SUFFIX = "__//!!##";

/**
 * Import specifiers must have forward slashes
 */
const toImportSpecifier = (file: string) => {
  const specifier = posix.normalize(file).replace(/\\/g, "/");

  if (!specifier.startsWith(".")) {
    return `./${specifier}`;
  }

  return specifier;
};

// Create a valid JS identifier out of the project relative specifier.
// Note that we only need to deal with strings that _must_ have been
// valid file names in Windows, macOS and Linux and every identifier we
// create here will be prefixed with at least one "$". This greatly
// simplifies the invalid characters we have to account for.
export const specifierToIdentifier = (specifier: string, used: Set<string>) => {
  // specifier = specifier.replace(/^(?:\.\/pkg)\//, "");
  const ext = path.extname(specifier);
  if (ext) {
    specifier = specifier.slice(0, -ext.length);
  }

  // Turn the specifier into a readable JS identifier
  let ident = "";
  for (let i = 0; i < specifier.length; i++) {
    const char = specifier.charCodeAt(i);
    if (i === 0 && !validatorIdentifier.isIdentifierStart(char)) {
      ident += "_";
      if (validatorIdentifier.isIdentifierChar(char)) {
        ident += specifier[i];
      }
    } else if (!validatorIdentifier.isIdentifierChar(char)) {
      if (ident[ident.length - 1] !== "_") {
        ident += "_";
      }
    } else if (ident[ident.length - 1] !== "_" || specifier[i] !== "_") {
      ident += specifier[i];
    }
  }

  if (used.has(ident)) {
    let check = ident;
    let i = 1;

    while (used.has(check)) {
      check = `${ident}_${i++}`;
    }

    ident = check;
  }

  used.add(ident);

  return ident;
};

const getSortFn = () => {
  const naturalCollator = new Intl.Collator(undefined, { numeric: true });

  return naturalCollator.compare;
};

const placeholder = (text: string) => {
  return `${PLACEHOLDER_PREFIX}${text}${PLACEHOLDER_SUFFIX}`;
};

export const writeManifestToString = async (
  collection: Array<[string, Array<[string, unknown]>]>,
) => {
  const sortFn = getSortFn();

  const used = new Set<string>();
  const imports = [];
  const manifest = {
    // baseUrl: placeholder("import.meta.url"),
    exports: [] as Array<string>,
  };

  for (const [file, exports] of collection) {
    const specifier = toImportSpecifier(file);
    const identifier = specifierToIdentifier(file, used);

    imports.push(
      `import * as ${IMPORT_PREFIX}${identifier} from "${specifier}";`,
    );

    const ref = (target: unknown) => {
      const name = (target as { name: string }).name;

      return placeholder(`${IMPORT_PREFIX}${identifier}.${name}`);
    };

    for (const [, moduleFn] of exports) {
      manifest.exports.push(ref(moduleFn));
    }
  }

  imports.sort(sortFn);
  const importsSerialized = imports.join("\n");

  manifest.exports.sort(sortFn);
  const manifestSerialized = JSON.stringify(manifest, null, 2)
    .replaceAll(`"${PLACEHOLDER_PREFIX}`, "")
    .replaceAll(`${PLACEHOLDER_SUFFIX}"`, "");

  const output =
    `// This file is generated by cool collector. Your changes might be overwritten.

${importsSerialized}

export const manifest = ${manifestSerialized};
`;

  const manifestStr = await formatter.format(output);

  return manifestStr;
};

export const buildManifest = async (
  target: WritableStream,
  options: collector.CollectExportsOptions,
) => {
  const collection = await collector.collectExports(options);

  const manifestStr = await writeManifestToString(collection);

  const outputWriter = target.getWriter();
  await outputWriter.ready;

  const encoded = new TextEncoder().encode(manifestStr);
  await outputWriter.write(encoded);

  outputWriter.releaseLock();

  const exportModules = Object.values(collection);
  const exportCount = exportModules.reduce((acc, [, moduleFns]) => {
    acc += moduleFns.length;
    return acc;
  }, 0);

  logger.current.info(
    `The manifest file has been generated for ${exportCount} exports in ${exportModules.length} modules.`,
  );
};

export const buildManifestFile = async (
  filepath: string,
  options: collector.CollectExportsOptions,
) => {
  const target = await runtime.current.open(filepath, {
    create: true,
    write: true,
  });

  await buildManifest(target.writable, options);

  target.close();
};
